# NanoRedis 整体架构与设计哲学

> 本系列文档是一套 Redis 服务器实现的学习指南。NanoRedis 是一个参考 [Dragonfly](https://github.com/dragonflydb/dragonfly) 设计的高性能 Redis 兼容服务器，采用 Shared-Nothing 架构、Fiber 并发模型和紧凑数据结构。通过阅读本系列文档，你将了解从网络协议解析到数据存储的完整实现。

## 文档导航

| 文档 | 主题 | 核心问题 |
|------|------|---------|
| **本文** | 整体架构与设计哲学 | NanoRedis 是什么？为什么这样设计？ |
| [1.nano_obj.md](1.nano_obj.md) | 核心数据表示 | 如何用 16 字节存储任意 Redis 值？ |
| [2.dashtable.md](2.dashtable.md) | 哈希表设计 | 如何实现增量扩容的高性能哈希表？ |
| [3.shared_nothing.md](3.shared_nothing.md) | Shared-Nothing 架构 | 如何实现无锁的多线程服务器？ |
| [4.resp_and_pipeline.md](4.resp_and_pipeline.md) | RESP 协议与 Pipeline | 如何高效解析协议和批量处理请求？ |
| [5.command_and_ttl.md](5.command_and_ttl.md) | 命令处理与过期机制 | 命令如何注册、路由和执行？TTL 如何工作？ |
| [6.performance_and_debug.md](6.performance_and_debug.md) | 性能分析与调试 | 如何定位性能瓶颈和内存问题？ |

---

## 1. Redis 服务器的核心挑战

实现一个 Redis 服务器需要解决以下关键问题：

```
客户端请求
    │
    ▼
┌──────────────────┐
│  网络 I/O         │ ─── 如何高效处理数万并发连接？
├──────────────────┤
│  协议解析         │ ─── 如何快速解析 RESP 协议？
├──────────────────┤
│  命令路由         │ ─── 如何将命令分发到正确的数据分片？
├──────────────────┤
│  数据存储         │ ─── 如何在内存中高效存储键值对？
├──────────────────┤
│  过期清理         │ ─── 如何及时清理过期的键？
└──────────────────┘
```

NanoRedis 对每一层都做了精心设计，下面逐一介绍。

## 2. 设计哲学

### 2.1 与 Redis 的对比

Redis（单线程）的架构：

```
┌─────────────────────────────────────┐
│            Redis 进程               │
│  ┌───────────────────────────────┐  │
│  │     单线程事件循环             │  │
│  │  ┌──────────┐ ┌──────────┐   │  │
│  │  │ 所有连接  │ │ 所有数据  │   │  │
│  │  └──────────┘ └──────────┘   │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
优点：无锁、实现简单
缺点：无法利用多核 CPU
```

NanoRedis（Shared-Nothing）的架构：

```
┌──────────────────────────────────────────────────────┐
│                  NanoRedis 进程                       │
│  ┌──────────┐  ┌──────────┐      ┌──────────┐       │
│  │  vCPU 0  │  │  vCPU 1  │ ...  │ vCPU N-1 │       │
│  │ ┌──────┐ │  │ ┌──────┐ │      │ ┌──────┐ │       │
│  │ │连接组 │ │  │ │连接组 │ │      │ │连接组 │ │       │
│  │ ├──────┤ │  │ ├──────┤ │      │ ├──────┤ │       │
│  │ │数据分片│ │  │ │数据分片│ │      │ │数据分片│ │       │
│  │ └──────┘ │  │ └──────┘ │      │ └──────┘ │       │
│  └──────────┘  └──────────┘      └──────────┘       │
│        ▲              ▲                ▲             │
│        └──── TaskQueue 消息传递 ────────┘             │
└──────────────────────────────────────────────────────┘
优点：线性可扩展、无锁数据路径
缺点：跨分片请求需要消息传递
```

### 2.2 三个核心设计原则

**原则一：Shared-Nothing（无共享）**

每个线程拥有独立的数据分片，线程之间不共享任何可变状态。消除了锁的需求，也消除了锁竞争带来的性能损失。

**原则二：Thread-per-Core（每核一线程）**

N 个 CPU 核心 = N 个线程 = N 个数据分片。线程绑定到 CPU 核心，数据保持在同一个 CPU 的缓存中，最大化缓存命中率。

**原则三：极致内存效率**

Redis 的一个关键瓶颈是内存。NanoRedis 通过 16 字节的 `NanoObj`（对比 Redis 的 `robj` 约 48 字节）和 Extendible Hashing 的 `DashTable` 来减少内存开销。

## 3. 整体架构

### 3.1 请求的完整生命周期

一个 `SET mykey myvalue` 命令从客户端发出到收到响应，经过以下阶段：

```
客户端发送: *3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n
                │
                ▼
┌───────────────────────────────────────────────────────────┐
│ 1. 网络层：SO_REUSEPORT 负载均衡到某个 vCPU              │
│    内核将连接分配到 vCPU X 的 TCP Server                  │
└───────────────────┬───────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────┐
│ 2. 连接层：Connection Fiber 处理连接                      │
│    每个客户端连接运行在独立的 Fiber（协程）中              │
└───────────────────┬───────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────┐
│ 3. 协议层：RESPParser 解析 RESP 协议                      │
│    解析出命令名 "SET" 和参数 ["mykey", "myvalue"]         │
└───────────────────┬───────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────┐
│ 4. 路由层：CommandRegistry 查找命令元数据                  │
│    查到 SET 的 arity=(-3), key_pos=(1), flags=(write)     │
│    对 "mykey" 计算 hash → 确定目标 shard                  │
└───────────────────┬───────────────────────────────────────┘
                    ▼
            ┌───────┴────────┐
            │ 本地 shard?     │
            └───┬────────┬───┘
           是   │        │ 否
                ▼        ▼
        直接执行    TaskQueue::Await()
                    发送到目标 shard
                    当前 Fiber 挂起
                    目标 shard 执行
                    唤醒当前 Fiber
                │        │
                └───┬────┘
                    ▼
┌───────────────────────────────────────────────────────────┐
│ 5. 执行层：StringFamily::Set() 执行命令                   │
│    在 Database 的 DashTable 中插入/更新键值对              │
│    如果有 EX/PX 参数，在 expire_table 中设置过期时间       │
└───────────────────┬───────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────┐
│ 6. 响应层：将 "+OK\r\n" 写入 Connection 的写缓冲区        │
│    如果缓冲区 ≥ 16KB 或没有更多 pipeline 命令，刷新发送    │
└───────────────────────────────────────────────────────────┘
                    ▼
客户端收到: +OK\r\n
```

### 3.2 核心组件关系

```
ShardedServer
    │
    ├── ProactorPool  ─── 管理 N 个 vCPU 线程
    │       │
    │       ├── vCPU 0
    │       │    ├── TCP Server (SO_REUSEPORT)
    │       │    ├── Connection Fibers ─── 每个客户端一个 Fiber
    │       │    │    ├── RESPParser ─── RESP 协议解析
    │       │    │    └── write_buffer ─── 响应缓冲
    │       │    └── Active Expire Fiber ─── 主动过期清理
    │       │
    │       ├── vCPU 1 ... (同上)
    │       └── vCPU N-1 ... (同上)
    │
    ├── EngineShardSet ─── 跨分片通信
    │       │
    │       ├── EngineShard 0
    │       │    ├── Database ─── 16 个逻辑数据库
    │       │    │    ├── DashTable<NanoObj, NanoObj> ─── 主数据表
    │       │    │    └── DashTable<NanoObj, int64_t> ─── 过期时间表
    │       │    └── TaskQueue ─── 无锁 MPMC 队列
    │       │
    │       ├── EngineShard 1 ... (同上)
    │       └── EngineShard N-1 ... (同上)
    │
    ├── CommandRegistry ─── 命令注册表（全局单例）
    │       ├── StringFamily ─── SET/GET/DEL/INCR/MGET/MSET...
    │       ├── HashFamily ─── HSET/HGET/HDEL/HGETALL...
    │       ├── SetFamily ─── SADD/SMEMBERS/SREM/SCARD...
    │       ├── ListFamily ─── LPUSH/RPUSH/LPOP/RPOP/LRANGE...
    │       └── ServerFamily ─── INFO/CONFIG/CLIENT/TIME...
    │
    └── ServerFamily ─── 管理命令（跨分片聚合）
```

## 4. 项目源码结构

```
nano_redis/
├── src/
│   ├── server_main.cc              # 入口：初始化 PhotonLibOS，创建 ShardedServer
│   ├── server/
│   │   ├── sharded_server.cc       # 服务器生命周期管理
│   │   ├── proactor_pool.cc        # vCPU 线程管理、连接处理、命令路由
│   │   ├── connection.cc           # 连接状态、响应缓冲
│   │   ├── engine_shard.cc         # 数据分片（Database + TaskQueue）
│   │   └── engine_shard_set.cc     # 跨分片通信（Await/Add）
│   ├── protocol/
│   │   └── resp_parser.cc          # RESP2 协议解析、Pipeline 支持
│   ├── command/
│   │   ├── command_registry.cc     # 命令注册与分发
│   │   ├── string_family.cc        # 字符串命令族
│   │   ├── hash_family.cc          # 哈希命令族
│   │   ├── set_family.cc           # 集合命令族
│   │   ├── list_family.cc          # 列表命令族
│   │   └── server_family.cc        # 管理命令族
│   └── core/
│       ├── database.cc             # 数据库操作、TTL/过期
│       ├── dashtable.cc            # Extendible Hashing 实现
│       ├── nano_obj.cc             # 16 字节通用值对象
│       ├── task_queue.cc           # 无锁 MPMC 队列
│       └── command_context.cc      # 命令执行上下文
├── include/                        # 头文件（与 src/ 结构对应）
├── tests/unit/                     # 单元测试
└── third_party/
    └── photonlibos/                # Fiber 调度 & 异步 I/O 库
```

## 5. 技术选型

| 组件 | 选择 | 为什么 |
|------|------|-------|
| 并发模型 | Fiber (PhotonLibOS) | 比 OS 线程更轻量，可支持数万并发连接 |
| I/O 模型 | io_uring / epoll | io_uring 性能最优，epoll 兼容性好 |
| 负载均衡 | SO_REUSEPORT | 内核级负载均衡，无需用户态 accept 线程 |
| 主哈希表 | DashTable (Extendible Hashing) | 增量扩容，不会出现 Redis 的 rehash 卡顿 |
| 内部哈希表 | ankerl::unordered_dense | 比 std::unordered_map 更快的开地址哈希表 |
| 值对象 | NanoObj (16B) | 比 Redis robj (48B) 节省 67% 内存 |
| 跨分片通信 | 无锁 MPMC 队列 | 避免锁竞争，Fiber 友好的挂起/唤醒 |
| 内存分配器 | mimalloc (可选) | 多线程场景下优于 glibc malloc |

## 6. 构建与运行

### 编译

```bash
# Debug 模式（含调试符号，方便 gdb/valgrind）
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build -j

# Release 模式（开启优化）
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
```

### 运行服务器

```bash
# 4 个分片，监听 9527 端口
./build/nano_redis_server --num_shards=4 --port=9527
```

### 运行测试

```bash
# 全部测试
./build/unit_tests

# 单个测试
./build/unit_tests --gtest_filter=StringFamilyTest.SetAndGet
```

### 使用 redis-cli 连接

```bash
redis-cli -p 9527
127.0.0.1:9527> SET hello world
OK
127.0.0.1:9527> GET hello
"world"
```

## 7. 阅读建议

如果你想深入理解 NanoRedis 的实现，建议按照以下顺序阅读：

1. **先读本文**，建立整体架构认知
2. **[NanoObj](1.nano_obj.md)**：理解最基础的数据表示——所有数据最终都存储在 NanoObj 中
3. **[DashTable](2.dashtable.md)**：理解数据是如何组织和查找的——这是 Redis 的核心数据结构
4. **[Shared-Nothing](3.shared_nothing.md)**：理解多线程架构——数据如何被分片、请求如何被路由
5. **[RESP 与 Pipeline](4.resp_and_pipeline.md)**：理解网络协议层——字节流如何变成命令
6. **[命令处理与 TTL](5.command_and_ttl.md)**：理解业务逻辑层——命令如何注册、执行、过期如何管理
7. **[性能与调试](6.performance_and_debug.md)**：理解如何优化和排查问题

每篇文档都可以独立阅读，但按顺序阅读会帮助你建立更完整的知识体系。
