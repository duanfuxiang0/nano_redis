# NanoObj：16 字节的通用值对象

> 在 Redis 中，每个键和值都需要一个对象来表示。Redis 使用 `robj`（约 48 字节）和 `sds`（变长字符串）。NanoRedis 设计了 `NanoObj`——一个仅 16 字节的通用对象，通过精巧的内存布局实现了极致的空间优化。

## 1. 为什么需要自定义对象？

### 1.1 Redis 的内存问题

在 Redis 中存储一个简短的键值对（如 `SET k v`），实际的内存开销远超数据本身：

```
Redis 存储 "hello" → "world"

键（robj）:           48 字节
键的 SDS 字符串:       ~14 字节 (sds header 9B + "hello" 5B)
值（robj）:           48 字节
值的 SDS 字符串:       ~14 字节 (sds header 9B + "world" 5B)
dictEntry:            24 字节
─────────────────────────────
总计:                 ~148 字节  （实际数据仅 10 字节）
```

### 1.2 NanoObj 的改进

```
NanoRedis 存储 "hello" → "world"

键（NanoObj）:         16 字节  （"hello" 内联存储）
值（NanoObj）:         16 字节  （"world" 内联存储）
DashTable Entry:      ~40 字节
─────────────────────────────
总计:                 ~72 字节  （节省 51%）
```

**核心思路**：大部分 Redis 键和值都是短字符串或整数，应该尽量避免堆分配。

## 2. 内存布局

### 2.1 整体结构

NanoObj 的 16 字节被精确划分为三个部分：

```
┌───────────────────────────────────────────────────────────┐
│                    NanoObj (16 字节)                       │
├─────────┬─────────┬───────────────────────────────────────┤
│ taglen_ │  flag_  │            union U (14 字节)           │
│  1 字节  │  1 字节  │                                       │
├─────────┴─────────┼───────────────────────────────────────┤
│ 偏移量 0-1         │ 偏移量 2-15                            │
└───────────────────┴───────────────────────────────────────┘
```

```cpp
class NanoObj {
    uint8_t taglen_;           // 类型标签 或 内联字符串长度
    uint8_t flag_;             // 位图标志（保留）
    union U {
        char data[kInlineLen]; // 内联字符串（14 字节）
        SmallString small_str; // 堆分配字符串的元数据
        RobjWrapper robj;      // 复合类型（Hash/Set/List/ZSet）
        int64_t ival;          // 整数值
    } u_;
};

static_assert(sizeof(NanoObj) == 16);
```

### 2.2 Tag 系统

`taglen_` 字段身兼二职——既是类型标签，又是内联字符串的长度：

```
taglen_ 的值：

0 ~ 14  →  内联字符串，值即为字符串长度
   15   →  INT_TAG        整数类型
   16   →  SMALL_STR_TAG  堆分配字符串
   17   →  ROBJ_TAG       复合类型（Hash/Set/List/ZSet）
   18   →  EXTERNAL_TAG   外部对象（保留）
   19   →  JSON_TAG       JSON 对象（保留）
   20   →  SBF_TAG        Bloom Filter（保留）
   31   →  NULL_TAG       空对象
```

这种设计的巧妙之处：对于最常见的短字符串，`taglen_` 直接记录长度，无需额外的类型判断字段。

### 2.3 四种存储模式

根据 `taglen_` 的值，`union U` 的 14 字节有四种解释方式：

```
模式 1：内联字符串（taglen_ ∈ [0, 14]）
┌────────────────────────────────────────────────┐
│ u_.data[0] ... u_.data[13]                     │
│ 直接存储字符串内容，无需堆分配                    │
└────────────────────────────────────────────────┘
适用于 ≤14 字节的字符串（覆盖大部分 Redis 键名）

模式 2：整数（taglen_ = INT_TAG）
┌────────────────────────────────────────────────┐
│ u_.ival (int64_t, 8字节)  │  6 字节填充          │
│ 直接存储 64 位整数                               │
└────────────────────────────────────────────────┘
适用于整数值和可转为整数的键

模式 3：堆字符串（taglen_ = SMALL_STR_TAG）
┌────────────────────────────────────────────────┐
│ ptr (8B)     │ length (2B) │ prefix[4] (4B)    │
│ 堆指针       │ 字符串长度   │ 前 4 字节缓存      │
└────────────────────────────────────────────────┘
适用于 >14 字节的字符串（最大 65535 字节）

模式 4：复合对象（taglen_ = ROBJ_TAG）
┌────────────────────────────────────────────────┐
│ inner_obj_ (8B)   │ sz_ (4B) │type(1B)│enc(1B)│
│ 指向底层数据结构    │ 元素数量  │Redis类型│编码方式│
└────────────────────────────────────────────────┘
适用于 Hash、Set、List、ZSet
```

## 3. 存储策略详解

### 3.1 字符串存储的自动选择

当你创建一个字符串 NanoObj 时，它会根据长度自动选择最优策略：

```
输入字符串
    │
    ├─ 长度 ≤ 14 字节 ───► 内联存储
    │                      taglen_ = 长度
    │                      数据复制到 u_.data
    │                      零堆分配 ✓
    │
    └─ 长度 > 14 字节 ───► SmallString 存储
                           taglen_ = SMALL_STR_TAG
                           ptr → 堆分配的字符串
                           length = 字符串长度
                           prefix = 前 4 字节缓存
```

**示例：内联存储**

```cpp
NanoObj obj("hello");  // 5 字节，内联存储

// 内存布局:
// [05] [00] [h] [e] [l] [l] [o] [0] [0] [0] [0] [0] [0] [0] [0] [0]
//  tag  flag  ← ────── u_.data (14字节) ────────────────────── →
```

**示例：堆分配存储**

```cpp
NanoObj obj("This is a long string exceeding 14 bytes");

// 内存布局:
// [10] [00] [ptr──────────] [len] [T] [h] [i] [s]
//  tag  flag  堆指针(8B)    长度(2B)  前缀缓存(4B)
//             └─► 指向堆上的完整字符串
```

### 3.2 键的整数优化

当 NanoObj 用作键时，会尝试将纯数字字符串优化为整数存储：

```cpp
NanoObj key1 = NanoObj::fromKey("12345");    // → 整数存储（8 字节足够）
NanoObj key2 = NanoObj::fromKey("user:1");   // → 字符串存储（无法转整数）
NanoObj key3 = NanoObj::fromKey("9999999999999999999"); // → 整数存储
```

**优化条件**：
1. 字符串长度 ≤ 20（`int64_t` 最大 19 位 + 符号）
2. 内容可以完整解析为 `int64_t`

**优化收益**：

| 键 | 未优化 | 优化后 | 节省 |
|---|-------|-------|-----|
| `"123"` | 内联 3B（16B对象） | 整数 8B（16B对象） | 等价，但比较更快 |
| `"12345678901234567"` | SmallString + 堆分配 | 整数 8B（16B对象） | 省去堆分配 ~24B |

### 3.3 复合类型的表示

Hash、Set、List、ZSet 使用 `RobjWrapper`——一个刚好 14 字节的 packed 结构体：

```cpp
struct RobjWrapper {
    void* inner_obj_;  // 8B：指向底层数据结构
    uint32_t sz_;      // 4B：元素数量
    uint8_t type_;     // 1B：Redis 类型（OBJ_HASH/OBJ_SET/...）
    uint8_t encoding_; // 1B：编码方式
} __attribute__((packed));

static_assert(sizeof(RobjWrapper) == 14);
```

底层数据结构的对应关系：

| Redis 类型 | type_ | inner_obj_ 指向 |
|-----------|-------|----------------|
| Hash | OBJ_HASH | `DashTable<NanoObj, NanoObj>*` |
| Set | OBJ_SET | `std::unordered_set<NanoObj>*` |
| List | OBJ_LIST | `std::vector<NanoObj>*` |
| ZSet | OBJ_ZSET | 跳表（SkipList） |

## 4. 比较与哈希

### 4.1 相等性比较

NanoObj 的比较需要处理跨类型的情况——一个整数键 `fromKey("123")` 必须能和字符串值 `"123"` 正确比较：

```
比较 a == b 的判定流程：

a.tag      b.tag       策略
────────   ────────    ─────────────────────
INT        INT         直接比较 ival
字符串      字符串       比较 string_view
INT        字符串       转为字符串后比较
字符串      INT         转为字符串后比较
其他                   返回 false
```

### 4.2 哈希计算

NanoObj 为 `ankerl::unordered_dense` 提供了特化的 hash 函数：

```
内联字符串  →  hash(string_view(data, length))
整数        →  hash(int64_t)
堆字符串    →  hash(prefix)  // 用 4 字节前缀近似哈希
```

**前缀哈希的权衡**：堆字符串只用前 4 字节做哈希，可能增加冲突率，但避免了遍历整个字符串的开销。在 DashTable 的 segment 内部，冲突会通过相等性比较来解决。

## 5. 生命周期管理

### 5.1 拷贝语义

```
拷贝 NanoObj 的行为：

内联字符串  →  memcpy 16 字节（O(1)，无堆操作）
整数        →  拷贝数值（O(1)）
堆字符串    →  分配新内存 + 复制字符串（O(n)）
复合对象    →  只拷贝元数据，不深拷贝底层对象
```

### 5.2 移动语义

移动操作总是 O(1)：直接复制 16 字节，然后将源对象重置为 `NULL_TAG`。

### 5.3 析构

```cpp
// 析构时只需要释放堆分配的内存
if (tag == SMALL_STR_TAG) → delete[] ptr
if (tag == ROBJ_TAG && inner_obj_ != nullptr) → delete inner_obj_
// 内联字符串和整数无需释放
```

## 6. 设计权衡

### 6.1 为什么是 16 字节？

```
总大小 16B = taglen_(1B) + flag_(1B) + union(14B)

union 的 14B 由最大的成员决定：
  - SmallString: ptr(8B) + length(2B) + prefix(4B) = 14B ✓
  - RobjWrapper: inner_obj_(8B) + sz_(4B) + type_(1B) + encoding_(1B) = 14B ✓
  - int64_t: 8B（剩余 6B 浪费但不可避免）
  - 内联字符串: 14B
```

16 字节是 CPU 缓存行（64 字节）的 1/4，可以在一个缓存行中容纳 4 个 NanoObj。

### 6.2 为什么不用 `std::variant`？

| | 手动 Tag + Union | std::variant |
|---|---|---|
| 大小 | 16B（精确控制） | ≥24B（variant 有自己的 index） |
| 性能 | 零抽象开销 | 访问时的类型检查开销 |
| 灵活性 | 可以混合使用 tag 语义 | 类型严格分离 |
| 安全性 | 需要手动保证类型安全 | 编译器保证类型安全 |

在存储百万级键值对的场景下，每个对象省 8 字节就意味着省 8MB 内存。

### 6.3 堆字符串的 65535 限制

`SmallString.length` 是 `uint16_t`（2 字节），最大表示 65535。这是一个有意的权衡——Redis 中绝大多数字符串都远小于 64KB，节省的 2 字节（相比 `uint32_t`）在百万级对象场景下是值得的。

## 7. 使用示例

```cpp
// 字符串操作
NanoObj str = NanoObj::fromString("hello");     // 内联
NanoObj long_str = NanoObj::fromString("a very long string..."); // 堆

// 整数操作
NanoObj num = NanoObj::fromInt(42);

// 键操作（自动优化）
NanoObj key = NanoObj::fromKey("12345");        // 优化为整数
NanoObj key2 = NanoObj::fromKey("user:alice");  // 保持字符串

// 类型查询
str.isString();  // true
num.isInt();     // true

// 值访问
str.getStringView();  // "hello"
num.getIntValue();    // 42
str.toString();       // "hello"（统一转为 std::string）

// 复合类型
NanoObj hash = NanoObj::fromHash();
auto* table = new DashTable<NanoObj, NanoObj>();
table->Insert(NanoObj::fromKey("field1"), NanoObj("value1"));
hash.setObj(table);
```

## 8. 与 Redis 对象系统的对比

| 特性 | Redis robj + SDS | NanoObj |
|------|-----------------|---------|
| 对象大小 | ~48B (robj) + 变长 (SDS) | 固定 16B |
| 短字符串 | embstr 编码 (~44B) | 内联存储 (16B) |
| 引用计数 | 有（共享对象） | 无（值语义） |
| 类型标识 | 独立字段 | 复用 taglen_ |
| 编码优化 | 多种编码 (int/embstr/raw) | 3 种模式 (inline/int/small_str) |
| LRU/LFU | 24 bits | 无（由上层管理） |

NanoObj 牺牲了引用计数和 LRU 追踪，换取了极致的内存紧凑性。在 Shared-Nothing 架构下，每个分片独立管理数据，引用计数的需求大大降低。

---

下一篇：[DashTable：增量扩容的高性能哈希表](2.dashtable.md)
