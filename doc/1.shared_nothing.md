# Shared-Nothing 架构

NanoRedis 的设计可以概括成一句话：**每个分片都有唯一的归属线程（owner thread）**。
记住这句话，服务端的大多数选择都会变得很自然：分片内的数据结构只会被这一个线程读写；其他线程想在该分片上执行工作，只能通过消息传递把任务发过去。

你也可以把 NanoRedis 想象成：**一个进程里住着 N 个“小而单线程”的 Redis-like 小服务器**。
它们各自有数据、各自跑事件循环，并且都有一个任务队列，用来接收其他分片发来的请求。

## 心智模型

- **一个 vCPU 线程 = 一个分片**（`EngineShard` + 它的 `Database`），线程对该分片有唯一的数据访问权。
- 热路径上**没有共享可变状态**，所以 DB 周围**不需要锁**。
- **连接是协调者**（fiber）：负责解析命令、决定在哪个分片执行、再把结果回给客户端。
- **跨分片靠消息传递**：通过 `TaskQueue` 发送任务，而不是直接访问其他分片的数据。

```
┌─────────────────────────────────────────────────────────────────┐
│                       NanoRedis Process                         │
├─────────────────────────────────────────────────────────────────┤
│  vCPU 0                vCPU 1               vCPU N-1            │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐      │
│  │ TCP Accept  │      │ TCP Accept  │      │ TCP Accept  │      │
│  │ (SO_REUSEPORT)     │ (SO_REUSEPORT)     │ (SO_REUSEPORT)     │
│  ├─────────────┤      ├─────────────┤      ├─────────────┤      │
│  │ Connection  │      │ Connection  │      │ Connection  │      │
│  │ Fibers      │      │ Fibers      │      │ Fibers      │      │
│  ├─────────────┤      ├─────────────┤      ├─────────────┤      │
│  │ EngineShard │      │ EngineShard │      │ EngineShard │      │
│  │ (Database)  │      │ (Database)  │      │ (Database)  │      │
│  ├─────────────┤      ├─────────────┤      ├─────────────┤      │
│  │ TaskQueue   │◄────►│ TaskQueue   │◄────►│ TaskQueue   │      │
│  └─────────────┘      └─────────────┘      └─────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

## 关键组件（它们各自负责什么）

- `ProactorPool`：拉起 N 个 vCPU 线程，每个线程跑一个 Photon 事件循环；每个线程都用 `SO_REUSEPORT`
  监听同一端口，从而让 accept 在内核层面做负载均衡。
- `EngineShard`：分片的数据所有者；它持有 `Database`，并且只在自己的线程上执行 DB 相关工作。
- `EngineShardSet`：跨分片任务的调度接口；它提供：
  - `Await(shard_id, func)`：把 `func` 送到目标分片执行，并等待结果（对 fiber 友好）。
  - `Add(shard_id, func)`：提交任务但不等待返回（fire-and-forget）。

## 请求怎么走

### 同分片（快路径）

如果 key 属于当前连接 fiber 所在的分片，那就本地直接执行。

```
Client ─────► vCPU X ─────► Shard X (local)
              │                 │
              ▼                 ▼
         Connection         DB operation
         Fiber              (no hop)
```

### 跨分片（一次“跳转”）

如果 key 属于另一个分片，连接 fiber 会让目标分片来执行该操作。
重点在这里：**OS 线程不会被阻塞**；只是 fiber 让出执行权。

```
Client ─────► vCPU X ─────────────► TaskQueue Y ─────► vCPU Y
              │                                           │
              ▼                                           ▼
         Connection                                  Shard Y
         Fiber                                       executes
              │                                           │
              └────────────── wait for result ◄────────────┘
                              (fiber yields)
```

## PhotonLibOS（为什么合适）

PhotonLibOS 给 NanoRedis 提供了三样很对味的东西：

- fiber：把“每个连接一个线程”的模型变得很轻；
- 异步 socket：I/O 不阻塞；
- 每个 vCPU 一个基于 epoll 的事件循环。

## 得到什么，又付出什么

- **优点**：所有权清晰、没有锁竞争、缓存友好、吞吐能跟着核心数线性走。
- **代价**：跨分片会有额外开销；热 key 可能把某个分片压垮；多 key 命令需要做协调。

## 配置

```bash
./build/nano_redis_server --num_shards=4 --port=9527
```

- `--num_shards`：分片/vCPU 数量（默认：8）
- `--port`：监听端口（默认：9527）
