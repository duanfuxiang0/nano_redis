# NanoObj 设计笔记（16B 通用值容器）

`NanoObj` 是 NanoRedis 里最常出现的值类型：**命令参数**、**数据库键**、**数据库值**，都会尽量落在这个 16 字节的对象里。它的目标很明确：

- 让常见值（短字符串、整数）尽量**不分配堆内存**；
- 让少数复杂值（hash/set/list/…）也能用一个统一的壳子承载；
- 在不引入 `std::variant` 等更重抽象的前提下，保证布局可控、路径可预测。

代码位置：`include/core/nano_obj.h`、`src/core/nano_obj.cc`。

这篇文档按“先能用，再看懂”的顺序来：先建立心智模型，再拆开内存布局与关键路径，最后总结边界与坑。

---

## 1. 一张图：16 字节里到底装了什么

`NanoObj` 的布局刻意做成固定大小（`static_assert(sizeof(NanoObj) == 16)`）。其中最关键的是：**`taglen` 一字段两用**。

- 当 `taglen ∈ [0, 14]`：它不是 tag，而是“内联字符串长度”，数据放在 `u.data[14]`。
- 当 `taglen` 取其它值：它才表示一种编码（整数、小字符串、复合对象、空值等）。

内存结构可以粗略理解为：

```
NanoObj (16 bytes, packed)
┌──────────┬─────────┬───────────────────────────────┐
│ taglen   │ flag    │ union u (14 bytes)             │
│  1B      │  1B     │  data / ival / small / robj    │
└──────────┴─────────┴───────────────────────────────┘
```

更细一点（偏对照代码）：

```
offset  size  field
0       1     taglen   // inline str len or Tag
1       1     flag     // bitmap, currently mostly 0
2       14    u        // payload
```

`u` 的几种解释方式：

1) **内联字符串**（`taglen <= 14`）：

```
u.data[0..13]  // 直接存字节，不保证 '\0'
```

2) **整数**（`taglen == INT_TAG (15)`）：

```
u.ival (int64_t)  // 剩余空间无所谓
```

3) **小字符串**（`taglen == SMALL_STR_TAG (16)`）：

```
SmallString (packed, 14B)
┌────────────┬───────────┬────────────┐
│ ptr (8B)   │ len (2B)  │ prefix(4B) │
└────────────┴───────────┴────────────┘
```

4) **复合对象**（`taglen == ROBJ_TAG (17)`）：

```
RobjWrapper (packed, 14B)
┌──────────────┬─────────┬──────┬──────────┐
│ inner_obj(8B)│ sz (4B) │ type │ encoding  │
└──────────────┴─────────┴──────┴──────────┘
```

---

## 2. Tag：哪些值一定要记住

`NanoObj::Tag` 的约定（见 `include/core/nano_obj.h`）：

- `0..14`：保留给内联字符串长度
- `15`：`INT_TAG`
- `16`：`SMALL_STR_TAG`
- `17`：`ROBJ_TAG`
- `31`：`NULL_TAG`

另外还有 `EXTERNAL_TAG/JSON_TAG/SBF_TAG` 这些预留位，但当前代码路径基本不使用它们。

配合 Tag，还有一套 Redis 风格的 `type/encoding` 常量：

- `OBJ_STRING/OBJ_HASH/OBJ_SET/OBJ_LIST/OBJ_ZSET`
- `OBJ_ENCODING_RAW/INT/EMBSTR/HASHTABLE/SKIPLIST`

它们主要用于 `TYPE` 之类的查询（`GetType()/GetEncoding()`），以及后续复合类型扩展时的对齐。

---

## 3. 字符串：内联与 SmallString 两条路

字符串是 `NanoObj` 最常见的形态。策略很简单：**短的内联，长的走 SmallString**。

```
len = str.size()
  │
  ├─ len <= 14  ──► inline: taglen=len, bytes in u.data[14]
  │
  └─ len > 14   ──► small : taglen=SMALL_STR_TAG, heap bytes + (len,prefix)
```

SmallString 的 `length` 是 `uint16_t`，因此当前实现对“单个字符串长度”的真实上限是 `65535` 字节：

- `SetSmallString()`、`PrepareStringBuffer()` 会把 `len` 直接 `static_cast<uint16_t>(len)` 写进去；
- 如果传入超过 64KB 的 bulk string，`length` 会截断，行为会变得不正确。

这点不是“理论上的限制”，而是**当前实现约束**：调用方需要保证输入不要超过这个范围。

### prefix 有什么用？

`prefix[4]` 会在 `SetSmallString()` / `FinalizePreparedString()` 时被填充为前 4 个字节。
它的典型用途是“快速失败比较”，但需要说明：**当前 `operator==` 与 `hash<NanoObj>` 并没有使用 prefix 优化**，它更多是为后续优化留的结构位。

---

## 4. 整数：为什么很多参数会变成 INT_TAG

整数的存储是最干净的一条路径：`taglen = INT_TAG`，`u.ival = int64_t`，不分配。

更值得写清楚的是：**整数并不只来自 `FromInt()`**。NanoRedis 的解析路径会主动做“字符串转整数”的尝试：

- `NanoObj::FromKey()`：对 `<= 20` 字符、可解析为 `int64_t` 的字符串，直接存成 `INT_TAG`；
- `RESPParser::ReadBulkStringInto()`：读完 bulk string 后，会调用 `out.MaybeConvertToInt()`，同样会把可解析的字符串改写为 `INT_TAG`。

这意味着：你在命令里写 `SET k 123`，值很可能不是“字符串 123”，而是一个 `INT_TAG` 的 `NanoObj`。
对外语义不变（`ToString()` 会再把 `ival` 转回 `"123"`），但内部会省掉不少字符串处理和内存。

---

## 5. 复合对象：ROBJ_TAG 只是“外壳”，里面才是容器

当 `taglen == ROBJ_TAG` 时，`u.robj` 提供四个字段：

- `type`：hash/set/list/zset 等
- `encoding`：HASHTABLE/SKIPLIST/…
- `inner_obj`：指向真正容器的指针（堆上分配）
- `sz`：预留的 size 字段

需要强调两点实现细节：

1) `sz` 在当前实现里只在 `InitRobj()` 时被置为 0，后续没有维护，因此 `Size()` 对复合对象会返回 0。**不要依赖它**。
2) `inner_obj` 的释放由 `NanoObj::FreeRobj()` 负责，它会按 `type` 做 `delete`：

- `OBJ_LIST`：`std::deque<NanoObj>`
- `OBJ_SET`：`ankerl::unordered_dense::set<std::string>`
- `OBJ_HASH`：`ankerl::unordered_dense::map<std::string, std::string>`
- 其它类型：当前走 `::operator delete`（未来扩展需要补齐正确的 `delete` 分支）

这就是为什么 “ROBJ_TAG 是壳子，容器类型才是实质”：**一旦你把新的容器类型塞进 `inner_obj`，就必须同步更新 `FreeRobj()` 的释放逻辑**，否则要么泄漏，要么析构不完整。

### 复合对象怎么创建？

常用方式是：

```cpp
NanoObj h = NanoObj::FromHash();
using HashType =
    ankerl::unordered_dense::map<std::string, std::string, ankerl::unordered_dense::hash<std::string>>;
auto* table = new HashType();
h.SetObj(table);
```

对应 list/set 也是类似的 `FromList()/FromSet()` + `SetObj(new ...)`。

注：工程规范里我们通常避免 `new`，但这里是内部值容器的实现方式；它的释放路径是确定的（`FreeRobj()`），因此文档里仍然以代码真实形态为准。

---

## 6. “零拷贝”路径：PrepareStringBuffer / FinalizePreparedString

当解析 RESP bulk string 时，我们不想先读到 `std::string` 再拷贝进 `NanoObj`，因此 `NanoObj` 提供了两段式接口：

1. `PrepareStringBuffer(len)`：清理旧值，并返回一个可写缓冲区指针（内联 or 堆）。
2. 调用方把 `len` 字节写进去。
3. `FinalizePreparedString()`：如果走的是 SmallString，把 prefix 填好。
4. 可选：`MaybeConvertToInt()` 再尝试把“看起来像整数”的字符串改成 `INT_TAG`。

`RESPParser::ReadBulkStringInto()` 就是按照这个顺序使用的。

这条路径的价值是：对于长 bulk string，只做一次分配 + 一次 memcpy；对于短 bulk string，甚至不分配。

---

## 7. 比较与哈希：哪些能比，哪些不能比

这块非常“工程化”：`NanoObj` 的比较与哈希，只覆盖了我们在 DB key 场景里真正需要的部分。

### 7.1 operator==

当前实现（`src/core/nano_obj.cc`）的逻辑可以概括为：

- `INT_TAG` vs `INT_TAG`：比 `u.ival`
- “字符串形态” vs “字符串形态”（内联或 SmallString）：比 `GetStringView()`
- 其它组合：直接 `false`

因此，不存在“整数和字符串互转后再比”的逻辑；也不存在对 ROBJ 的深比较。

### 7.2 hash<NanoObj>

`include/core/unordered_dense.h` 里提供了 `hash<NanoObj>` 特化：

- 内联字符串 / SmallString：对 `GetStringView()` 的字节做 wyhash
- 整数：对 `GetIntValue()` 做 wyhash
- 其它 tag：返回 0

这也间接说明了一个事实：**NanoObj 作为哈希表 key 的有效形态就是“字符串或整数”**。
复合对象、空值等不应该作为 key 进入 DB 表，否则哈希会退化。

---

## 8. 拷贝 / 移动 / 析构：谁负责释放，什么时候释放

`NanoObj` 的资源释放集中在 `Clear()`：

- `SMALL_STR_TAG`：释放 `small_str.ptr`
- `ROBJ_TAG`：按 `type` 释放 `inner_obj`
- 其它类型：不需要释放

拷贝与移动的语义也比较直接：

- 拷贝：内联字符串与整数直接拷贝；SmallString 会深拷贝堆内容；其它 tag 当前会走“清零保守路径”（payload 被置 0，等价于不支持拷贝语义）。
- 移动：直接把 `u` 整体搬走，并把 `other` 重置成 `NULL_TAG`，让 moved-from 对象析构时不再释放资源。

这套语义保证了：值在 DB、参数向量、容器中来回移动时，不会出现重复释放。

---

## 9. 常用 API：该用哪个，不该用哪个

下面这几个是最常用、也最不容易踩坑的组合：

- 构造：
  - `NanoObj::FromKey(sv)`：用于命令参数/键/值（会尝试转整数）
  - `NanoObj::FromString(sv)`：明确要“按字符串存”的场景
  - `NanoObj::FromInt(v)`：明确要“按整数存”的场景
- 读取：
  - `GetStringView()`：拿字符串视图（支持内联与 SmallString）
  - `TryToInt()`：只在确实是整数时返回
  - `ToString()`：统一转字符串（可能分配）

特别要注意：

- `TryToString()` 只在“内联字符串”时返回 `std::string_view`；对 SmallString 它会返回 `nullopt`。
  如果你想对所有字符串形态都拿 view，请用 `GetStringView()`。

---

## 10. 现在的边界（写在文档里，避免默契）

- `SmallString::length` 是 `uint16_t`：当前实现要求字符串长度不超过 64KB。
- `u.robj.sz` 当前不维护：`Size()` 对复合对象不可用（返回 0）。
- `operator==` 只覆盖 int/string 的同类比较：不做跨类型比较，也不做复合对象深比较。
- `hash<NanoObj>` 对非 int/string 返回 0：复合对象不应作为哈希 key。
- `flag` 目前主要是预留位：大多数路径会把它置为 0。

---

## 参考

- `include/core/nano_obj.h`
- `src/core/nano_obj.cc`
- `src/protocol/resp_parser.cc`（bulk string 解析使用 `PrepareStringBuffer()`）
- `include/core/unordered_dense.h`（`hash<NanoObj>` 特化）
