# RESP 协议解析与 Pipeline 批处理

> 客户端和 Redis 服务器之间使用 RESP（Redis Serialization Protocol）协议通信。高效的协议解析直接影响服务器吞吐量。NanoRedis 实现了完整的 RESP2 解析器，并通过 Pipeline 批处理机制将多个命令的响应合并发送，大幅减少系统调用次数。

## 1. RESP 协议基础

### 1.1 协议结构

RESP 是一个基于文本的二进制安全协议，每种数据类型以第一个字节标识：

```
类型标识     格式                          示例
─────────   ─────────────────────────     ──────────────────
+ 简单字符串  +内容\r\n                     +OK\r\n
- 错误       -错误信息\r\n                  -ERR unknown command\r\n
: 整数       :数值\r\n                      :1000\r\n
$ 批量字符串  $长度\r\n内容\r\n              $5\r\nhello\r\n
* 数组       *元素数量\r\n...              *2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
```

### 1.2 客户端发送命令

客户端将命令编码为 RESP 数组：

```
命令: SET mykey myvalue

编码:
  *3\r\n          ← 3 个元素的数组
  $3\r\n          ← 第 1 个元素：3 字节
  SET\r\n         ← 命令名
  $5\r\n          ← 第 2 个元素：5 字节
  mykey\r\n       ← 键
  $7\r\n          ← 第 3 个元素：7 字节
  myvalue\r\n     ← 值
```

### 1.3 服务器返回响应

```
+OK\r\n                          ← 简单字符串（SET 的成功响应）
$5\r\nhello\r\n                  ← 批量字符串（GET 的返回值）
$-1\r\n                          ← 空值（键不存在）
:42\r\n                          ← 整数（INCR 的返回值）
*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n ← 数组（MGET 的返回值）
-ERR wrong number of arguments\r\n ← 错误
```

### 1.4 Inline 命令

除了标准 RESP 格式，Redis 还支持简单的空格分隔格式（方便 telnet 调试）：

```
RESP 格式: *3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n
Inline 格式: SET mykey myvalue\r\n
```

NanoRedis 的解析器同时支持两种格式。

## 2. RESPParser 设计

### 2.1 解析器结构

```cpp
class RESPParser {
    photon::net::ISocketStream* socket_;  // 网络 socket

    char buffer_[8192];        // 8KB 固定读取缓冲区
    size_t buffer_pos_;        // 当前读取位置
    size_t buffer_size_;       // 缓冲区有效数据量

    std::string scratch_line_; // 跨 buffer 的行拼接缓冲
    std::string scratch_inline_; // inline 命令拼接缓冲

    bool allow_socket_read_;   // 是否允许从 socket 读取
    bool no_read_need_more_;   // 标记 no-read 解析需要更多数据
};
```

### 2.2 缓冲区管理

解析器使用固定大小的 8KB 缓冲区，通过维护 `buffer_pos_` 和 `buffer_size_` 来跟踪未消费的数据：

```
初始状态（刚从 socket 读取）:
┌────────────────────────────────────────────────────────┐
│ *3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n   │
└────────────────────────────────────────────────────────┘
  ↑ buffer_pos_ = 0                     buffer_size_ = 47

解析 "*3\r\n" 后:
┌────────────────────────────────────────────────────────┐
│ *3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n   │
└────────────────────────────────────────────────────────┘
       ↑ buffer_pos_ = 4               buffer_size_ = 47

全部解析后:
┌────────────────────────────────────────────────────────┐
│ *3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n   │
└────────────────────────────────────────────────────────┘
                                                       ↑
                              buffer_pos_ = 47 = buffer_size_
                              → 缓冲区已空，下次需要从 socket 读取
```

**跨缓冲区的数据处理**：

当一个命令跨越两次 `recv()` 调用时，解析器使用 `scratch_line_` 拼接：

```
第一次 recv:
  [... $5\r\nmyk]    ← "mykey" 被截断
                      scratch_line_ = "myk"

第二次 recv:
  [ey\r\n ...]       ← 补全剩余部分
                      scratch_line_ += "ey" → "mykey"
```

### 2.3 解析流程

```
ParseCommand(args)
    │
    ├── FillBuffer()         ← 如果缓冲区为空，从 socket 读取
    │
    ├── 查看第一个字节
    │   │
    │   ├── '*' → ParseArray(args)
    │   │           ├── 读取数组长度
    │   │           └── 循环读取 N 个 BulkString
    │   │               ├── 读取 "$长度\r\n"
    │   │               └── 读取 "内容\r\n"
    │   │
    │   └── 其他 → ParseInlineCommand(args)
    │               ├── 读取一行
    │               └── 按空格分割为参数
    │
    └── 返回解析结果
        ├── ≥ 0  → 成功（消费的字节数）
        └── < 0  → 失败
```

### 2.4 零拷贝优化

对于 Bulk String 的读取，解析器直接将数据写入 `NanoObj`，避免中间复制：

```
传统方式:
  socket → buffer → std::string → NanoObj    （2 次复制）

NanoRedis:
  socket → buffer → NanoObj                   （1 次复制）
  ReadBulkStringInto() 直接构造 NanoObj
```

## 3. Pipeline 批处理

### 3.1 什么是 Pipeline？

通常客户端发送一个命令后等待响应，再发送下一个：

```
无 Pipeline（一来一回）:
  Client                    Server
    │── SET k1 v1 ──────────►│
    │◄──────────── +OK ──────│
    │── SET k2 v2 ──────────►│
    │◄──────────── +OK ──────│
    │── GET k1 ─────────────►│
    │◄──────── $2\r\nv1 ─────│

  3 个命令 = 6 次网络交互（3 次 RTT）
```

Pipeline 允许客户端一次性发送多个命令，服务器一次性返回所有响应：

```
Pipeline（批量处理）:
  Client                    Server
    │── SET k1 v1 ──────────►│
    │── SET k2 v2 ──────────►│  ← 不等待响应，继续发送
    │── GET k1 ─────────────►│
    │                        │
    │◄─── +OK ──────────────│
    │◄─── +OK ──────────────│  ← 一次性返回所有响应
    │◄─── $2\r\nv1 ─────────│

  3 个命令 = 2 次网络交互（1 次 RTT）
```

### 3.2 NanoRedis 的 Pipeline 实现

Pipeline 的实现分为三个关键机制：

**机制一：响应缓冲**

```cpp
class Connection {
    std::string write_buffer;  // 响应缓冲区

    void AppendResponse(std::string_view resp) {
        write_buffer.append(resp);
    }

    bool Flush() {
        // 将缓冲区内容写入 socket
        ssize_t ret = socket_->write(write_buffer.data(), write_buffer.size());
        write_buffer.clear();
        return ret >= 0;
    }

    size_t PendingResponseBytes() const {
        return write_buffer.size();
    }
};
```

不是每执行一个命令就写一次 socket，而是将响应追加到 `write_buffer`，积攒到一定量后一次性写入。

**机制二：无读解析（TryParseCommandNoRead）**

```cpp
TryParseResult TryParseCommandNoRead(std::vector<NanoObj>& args) {
    // 保存当前缓冲区状态
    size_t saved_pos = buffer_pos_;
    size_t saved_size = buffer_size_;

    allow_socket_read_ = false;   // 禁止从 socket 读取
    int ret = ParseCommand(args); // 尝试从缓冲区解析
    allow_socket_read_ = true;    // 恢复

    if (ret >= 0) {
        return OK;           // 缓冲区中有完整命令
    }

    // 解析失败，恢复缓冲区状态
    buffer_pos_ = saved_pos;
    buffer_size_ = saved_size;
    args.clear();
    return no_read_need_more_ ? NEED_MORE : ERROR;
}
```

这个方法的核心思想是：客户端通过 Pipeline 发送多个命令时，这些命令可能在一次 `recv()` 中被读入缓冲区。`TryParseCommandNoRead` 尝试不进行 socket 读取，直接从缓冲区中解析下一个命令。

**机制三：批处理循环**

```
Connection Fiber 的主循环:

    ┌─── ParseCommand()  ← 阻塞读取，等待第一个命令
    │
    ▼
    执行命令，AppendResponse() 到缓冲区
    │
    ▼
    ┌── TryParseCommandNoRead()  ← 非阻塞，尝试从缓冲区解析
    │   │
    │   ├── OK → 缓冲区中还有命令
    │   │        执行命令，AppendResponse()
    │   │        │
    │   │        ├── 缓冲区 ≥ 16KB? → Flush()  ← 防止缓冲区过大
    │   │        │
    │   │        └── 继续 TryParseCommandNoRead()
    │   │
    │   ├── NEED_MORE → 缓冲区中没有完整命令
    │   │               Flush() 写出所有响应
    │   │               回到 ParseCommand() 等待新数据
    │   │
    │   └── ERROR → 协议错误，关闭连接
    │
    └──────────────────────────────────────────
```

### 3.3 Pipeline 性能提升原理

```
无 Pipeline:
  每个命令: recv() → 解析 → 执行 → send()
  3 个命令 = 3×recv() + 3×send() = 6 次系统调用

Pipeline:
  recv() → 解析3个命令 → 执行3个 → send()
  3 个命令 = 1×recv() + 1×send() = 2 次系统调用
```

**系统调用是昂贵的**（每次 ~1μs），Pipeline 将 6 次系统调用减少到 2 次，对高吞吐场景意义重大。

### 3.4 16KB 刷新阈值

```
为什么选择 16KB 作为 Flush 阈值？

太小（如 1KB）:
  频繁 Flush → 系统调用增多 → 吞吐量下降
  TCP 小包 → Nagle 算法延迟

太大（如 1MB）:
  响应延迟增大 → 客户端等待时间增加
  内存占用增大

16KB:
  ≈ 10 个 TCP MSS → 足够填满几个 TCP 段
  延迟可控（一般 Pipeline 命令不多于几百个）
  经验值，与 Linux TCP 缓冲区大小匹配良好
```

## 4. 响应格式化

### 4.1 常量响应

NanoRedis 预定义了常用的响应字符串，避免重复构造：

```cpp
constexpr std::string_view kOkResponse = "+OK\r\n";
constexpr std::string_view kPongResponse = "+PONG\r\n";
constexpr std::string_view kNullBulkResponse = "$-1\r\n";
constexpr std::string_view kEmptyArrayResponse = "*0\r\n";
```

### 4.2 响应构造示例

```cpp
// 简单字符串
void ReplyOK(Connection& conn) {
    conn.AppendResponse("+OK\r\n");
}

// 错误
void ReplyError(Connection& conn, std::string_view msg) {
    conn.AppendResponse("-ERR ");
    conn.AppendResponse(msg);
    conn.AppendResponse("\r\n");
}

// 整数
void ReplyInteger(Connection& conn, int64_t val) {
    conn.AppendResponse(":");
    conn.AppendResponse(std::to_string(val));
    conn.AppendResponse("\r\n");
}

// 批量字符串
void ReplyBulkString(Connection& conn, std::string_view str) {
    conn.AppendResponse("$");
    conn.AppendResponse(std::to_string(str.size()));
    conn.AppendResponse("\r\n");
    conn.AppendResponse(str);
    conn.AppendResponse("\r\n");
}
```

## 5. 解析器的状态管理

### 5.1 解析器是有状态的

RESP 解析器需要在多次 `recv()` 之间保持状态——因为一个命令可能跨越多次网络读取：

```
场景: SET 命令被拆分为两个 TCP 段

第一个段: "*3\r\n$3\r\nSET\r\n$5\r\nmy"
  → 解析到 "my" 时发现数据不够
  → 需要保存 "已解析 2 个参数，正在读取第 3 个，已读 2 字节" 的状态

第二个段: "key\r\n$7\r\nmyvalue\r\n"
  → 续读 "key" 完成第 3 个参数
  → 读取第 4 个参数 "myvalue"
  → 命令完整，返回 OK
```

NanoRedis 通过 `scratch_line_` 缓冲区来处理跨段数据：未完成的行被暂存，下次读取时拼接完成。

### 5.2 TryParseCommandNoRead 的状态保护

`TryParseCommandNoRead` 是一个"投机"操作——它尝试解析，但可能失败。因此必须在失败时恢复缓冲区状态：

```
尝试解析前:
  buffer: [SET k2 v2\r\nGET k1\r\n]
  pos: 0

尝试解析 "SET k2 v2" → 成功:
  buffer: [SET k2 v2\r\nGET k1\r\n]
  pos: 12（跳过已解析部分）

再次尝试解析 "GET k1" → 成功:
  buffer: [SET k2 v2\r\nGET k1\r\n]
  pos: 22

再次尝试 → NEED_MORE:
  pos 不变（无更多数据）
  → Flush 响应，等待新数据
```

## 6. 与 Redis 的解析器对比

| 特性 | Redis | NanoRedis |
|------|-------|-----------|
| 缓冲区 | `querybuf` 动态增长 | 固定 8KB |
| 解析方式 | 增量状态机 | 递归下降 + 缓冲区回退 |
| Pipeline | 在事件循环中自然支持 | 显式 TryParseCommandNoRead |
| Inline 命令 | 支持 | 支持 |
| RESP3 | 支持（Redis 6+） | 仅 RESP2 |
| 多行值 | 支持 | 通过 scratch_line_ 拼接 |

NanoRedis 使用固定 8KB 缓冲区而非动态增长，避免了大量小分配。对于超过 8KB 的命令参数，通过 scratch 缓冲区拼接处理。

## 7. 端到端示例：Pipeline 处理流程

假设客户端通过 Pipeline 发送 3 个命令：

```
客户端一次性发送:
  *3\r\n$3\r\nSET\r\n$2\r\nk1\r\n$2\r\nv1\r\n
  *3\r\n$3\r\nSET\r\n$2\r\nk2\r\n$2\r\nv2\r\n
  *2\r\n$3\r\nGET\r\n$2\r\nk1\r\n
```

```
Connection Fiber:
│
├── ParseCommand()                       ← 阻塞读取
│   recv() 读取全部 3 个命令到 buffer
│   解析出: SET k1 v1
│
├── 路由到 shard → 执行 SET k1 v1
├── AppendResponse("+OK\r\n")            ← 缓冲，不发送
│
├── TryParseCommandNoRead()              ← 非阻塞
│   从 buffer 解析出: SET k2 v2 → OK
│
├── 路由到 shard → 执行 SET k2 v2
├── AppendResponse("+OK\r\n")            ← 缓冲，不发送
│   缓冲区 = 10 字节 < 16KB → 不 flush
│
├── TryParseCommandNoRead()              ← 非阻塞
│   从 buffer 解析出: GET k1 → OK
│
├── 路由到 shard → 执行 GET k1 → "v1"
├── AppendResponse("$2\r\nv1\r\n")       ← 缓冲
│
├── TryParseCommandNoRead()              ← 非阻塞
│   buffer 已空 → NEED_MORE
│
├── Flush()                              ← 一次性写入
│   send("+OK\r\n+OK\r\n$2\r\nv1\r\n")
│
└── 回到 ParseCommand() 等待新数据
```

客户端收到: `+OK\r\n+OK\r\n$2\r\nv1\r\n`

3 个命令只用了 1 次 recv() + 1 次 send() = 2 次系统调用。

---

上一篇：[Shared-Nothing 架构与 Fiber 并发模型](3.shared_nothing.md)
下一篇：[命令处理与 TTL 过期机制](5.command_and_ttl.md)
