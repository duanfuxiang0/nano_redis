# 命令处理与 TTL 过期机制

> Redis 支持上百个命令，每个命令有不同的参数格式、键位置和执行逻辑。NanoRedis 通过 `CommandRegistry` 实现元数据驱动的命令分发，通过 `CommandFamily` 组织相关命令。本文还深入介绍了 TTL 过期机制——Redis 的一个关键特性。

## 1. 命令注册与元数据

### 1.1 CommandMeta：命令的"身份证"

每个命令都有一个 `CommandMeta` 描述其特征：

```cpp
struct CommandMeta {
    int32_t arity;       // 参数数量（含命令名本身）
    int32_t first_key;   // 第一个键参数的位置
    int32_t last_key;    // 最后一个键参数的位置
    int32_t key_step;    // 键参数的步长
    uint32_t flags;      // 命令标志
};
```

**arity 的规则**：
- 正数：精确参数数量（如 `GET` 的 arity = 2，表示恰好 2 个参数：`GET key`）
- 负数：最少参数数量（如 `SET` 的 arity = -3，表示至少 3 个参数：`SET key value [EX ...]`）

**键位置示例**：

```
命令: SET mykey myvalue
      [0]  [1]    [2]

CommandMeta for SET:
  arity = -3
  first_key = 1      ← args[1] = "mykey"
  last_key = 1       ← 只有一个键
  key_step = 1
  flags = kCmdFlagWrite

命令: MGET key1 key2 key3
      [0]  [1]   [2]   [3]

CommandMeta for MGET:
  arity = -2
  first_key = 1      ← args[1] = "key1"
  last_key = -1      ← -1 表示最后一个参数
  key_step = 1       ← 每隔 1 个参数是一个键
  flags = kCmdFlagReadOnly | kCmdFlagMultiKey
```

### 1.2 命令标志

```cpp
kCmdFlagReadOnly  = 1 << 0   // 只读命令（GET, MGET, EXISTS...）
kCmdFlagWrite     = 1 << 1   // 写命令（SET, DEL, INCR...）
kCmdFlagAdmin     = 1 << 2   // 管理命令（CONFIG, INFO...）
kCmdFlagMultiKey  = 1 << 3   // 多键命令（MGET, MSET, DEL...）
kCmdFlagNoKey     = 1 << 4   // 无键命令（PING, INFO, TIME...）
```

标志的作用：
- **路由决策**：`NoKey` 命令不需要路由到特定分片
- **权限控制**：`Admin` 命令可以限制为管理端口
- **多键处理**：`MultiKey` 命令需要分组发送到多个分片

### 1.3 CommandRegistry：全局注册表

`CommandRegistry` 是一个全局单例，使用大小写不敏感的哈希表存储命令：

```cpp
class CommandRegistry {
    // 大小写不敏感的哈希表（FNV-1a 哈希 + 大小写归一化）
    absl::flat_hash_map<
        std::string,
        CommandEntry,
        CaseInsensitiveHash,
        CaseInsensitiveEq
    > command_meta;
};
```

**大小写不敏感的实现**：

```
查找 "set" / "SET" / "Set" 的过程:

① 计算哈希: 将每个字符转为大写后 FNV-1a 哈希
   hash("set") → toupper → hash("SET") = 0x1234...
   hash("SET") → toupper → hash("SET") = 0x1234...  ← 相同

② 相等比较: 逐字节比较，忽略大小写
   "set" == "SET" → 's'→'S', 'e'→'E', 't'→'T' → 相等
```

### 1.4 命令注册示例

```cpp
// 在 ShardedServer 构造函数中注册所有命令

// 字符串命令族
StringFamily::Register(&registry);
  // 内部注册:
  // registry.RegisterCommand("SET", StringFamily::Set, {-3, 1, 1, 1, kWrite});
  // registry.RegisterCommand("GET", StringFamily::Get, {2, 1, 1, 1, kReadOnly});
  // registry.RegisterCommand("DEL", StringFamily::Del, {-2, 1, -1, 1, kWrite|kMultiKey});
  // ...

// 哈希命令族
HashFamily::Register(&registry);

// 集合命令族
SetFamily::Register(&registry);

// 列表命令族
ListFamily::Register(&registry);

// 管理命令族
ServerFamily::Register(&registry);
```

## 2. 命令分发流程

### 2.1 从字节到执行

```
收到 args = ["SET", "mykey", "myvalue", "EX", "60"]
    │
    ▼
① 查找命令元数据
   meta = registry.FindMeta("SET")
   → { arity:-3, first_key:1, last_key:1, key_step:1, flags:write }
    │
    ▼
② 参数校验
   实际参数数 = 5, |arity| = 3, arity < 0 → 至少 3 个 → 通过
    │
    ▼
③ 判断是否需要路由
   flags & kCmdFlagNoKey? → 否，需要路由
    │
    ▼
④ 提取键并计算分片
   key = args[first_key] = args[1] = "mykey"
   target_shard = Hash("mykey") % num_shards
    │
    ▼
⑤ 路由执行
   target_shard == current_vcpu?
   ├── 是 → 直接调用 handler(args, context)
   └── 否 → shard_set.Await(target_shard, [&]{ handler(args, context); })
    │
    ▼
⑥ 将响应写入连接的缓冲区
```

### 2.2 两种 Handler 类型

```cpp
// 类型一：简单 Handler（不需要上下文）
using CommandHandler = std::function<std::string(const std::vector<NanoObj>&)>;

// 类型二：带上下文的 Handler（需要访问连接状态、数据库等）
using CommandHandlerWithContext = std::function<void(
    const std::vector<NanoObj>&,  // 命令参数
    CommandContext*               // 执行上下文
)>;
```

`CommandContext` 携带命令执行所需的全部信息：

```cpp
struct CommandContext {
    Connection* connection;    // 当前连接（响应写入目标）
    Database* database;        // 当前分片的数据库
    uint32_t db_index;         // 当前连接选择的逻辑 DB
    EngineShardSet* shard_set; // 跨分片通信
    uint32_t num_shards;       // 分片总数
};
```

## 3. 命令族详解

### 3.1 StringFamily：字符串命令

最基础也是最常用的命令族：

| 命令 | 格式 | 说明 |
|------|------|------|
| SET | `SET key value [EX s] [PX ms]` | 设置键值，可选过期时间 |
| GET | `GET key` | 获取值 |
| DEL | `DEL key [key ...]` | 删除键 |
| EXISTS | `EXISTS key` | 检查键是否存在 |
| INCR | `INCR key` | 原子递增 |
| DECR | `DECR key` | 原子递减 |
| INCRBY | `INCRBY key increment` | 原子加 |
| DECRBY | `DECRBY key decrement` | 原子减 |
| APPEND | `APPEND key value` | 追加字符串 |
| STRLEN | `STRLEN key` | 获取字符串长度 |
| MGET | `MGET key [key ...]` | 批量获取 |
| MSET | `MSET key value [key value ...]` | 批量设置 |

**SET 命令的实现逻辑**：

```
SET key value [EX seconds] [PX milliseconds]
    │
    ├── 解析可选参数（EX/PX）
    │
    ├── 在 DashTable 中 Insert 或 Update
    │   key = NanoObj::fromKey(args[1])
    │   value = NanoObj(args[2])
    │
    ├── 如果有 EX/PX → 在 expire_table 中设置过期时间
    │   expire_at_ms = now_ms + ttl_ms
    │
    └── 返回 "+OK\r\n"
```

### 3.2 HashFamily：哈希命令

| 命令 | 格式 | 说明 |
|------|------|------|
| HSET | `HSET key field value [field value ...]` | 设置哈希字段 |
| HGET | `HGET key field` | 获取哈希字段 |
| HDEL | `HDEL key field [field ...]` | 删除哈希字段 |
| HGETALL | `HGETALL key` | 获取所有字段和值 |
| HLEN | `HLEN key` | 获取字段数量 |
| HEXISTS | `HEXISTS key field` | 检查字段是否存在 |

**HSET 的内部实现**：

```
HSET user:1 name Alice age 30
    │
    ├── 在主 DashTable 中查找 "user:1"
    │   │
    │   ├── 不存在 → 创建 NanoObj::fromHash()
    │   │            创建新的 DashTable<NanoObj, NanoObj>
    │   │
    │   └── 存在 → 类型检查（必须是 Hash）
    │
    ├── 获取 inner DashTable
    │   auto* ht = hash_obj.getObj<DashTable<NanoObj, NanoObj>>()
    │
    ├── 插入字段
    │   ht->Insert(fromKey("name"), NanoObj("Alice"))
    │   ht->Insert(fromKey("age"), NanoObj("30"))
    │
    └── 返回 ":2\r\n"（新增字段数）
```

### 3.3 SetFamily / ListFamily

Set 和 List 命令遵循相似的模式：在主 DashTable 中查找键，获取底层数据结构（`std::unordered_set` 或 `std::vector`），然后执行操作。

### 3.4 ServerFamily：管理命令

管理命令通常不操作数据键，而是查询/修改服务器状态：

| 命令 | 说明 |
|------|------|
| PING | 返回 PONG |
| INFO | 返回服务器信息 |
| CONFIG GET/SET | 获取/设置配置 |
| CLIENT LIST/KILL | 客户端管理 |
| TIME | 服务器时间 |
| RANDOMKEY | 随机返回一个键 |
| SELECT | 选择逻辑数据库 |
| DBSIZE | 当前数据库的键数量 |
| FLUSHDB | 清空当前数据库 |
| KEYS | 返回匹配模式的所有键 |

**FLUSHDB 的跨分片实现**：

```
FLUSHDB
    │
    ▼
对每个分片执行清空操作（同步等待所有分片完成）:

for (shard_id = 0; shard_id < num_shards; shard_id++) {
    shard_set->Await(shard_id, [db_index]() {
        EngineShard::tlocal_shard_->db_.FlushDB(db_index);
    });
}
```

**KEYS 的跨分片聚合**：

```
KEYS pattern
    │
    ▼
从每个分片收集匹配的键:

std::vector<std::string> all_keys;
for (shard_id = 0; shard_id < num_shards; shard_id++) {
    shard_set->Await(shard_id, [&]() {
        // 扫描本分片的匹配键
        auto shard_keys = scan_keys(pattern);
        all_keys.insert(all_keys.end(), shard_keys.begin(), shard_keys.end());
    });
}
// 返回聚合结果
```

## 4. TTL 过期机制

### 4.1 Redis 的过期策略

Redis 的键过期需要回答一个核心问题：**如何及时删除过期的键，同时不影响正常请求的性能？**

答案是两种策略的结合：

```
┌─────────────────────────────────────────────────────┐
│                 过期策略                              │
│                                                     │
│  ① 惰性过期（Lazy Expiry）                           │
│     访问键时检查是否过期                               │
│     优点: 零额外开销                                  │
│     缺点: 不访问的键永远不会被清理                      │
│                                                     │
│  ② 主动过期（Active Expiry）                         │
│     定期扫描一批键，删除已过期的                        │
│     优点: 保证过期键最终被清理                          │
│     缺点: 有 CPU 开销                                │
│                                                     │
│  两者结合: 惰性保证正确性，主动保证及时性               │
└─────────────────────────────────────────────────────┘
```

### 4.2 数据结构

每个逻辑数据库维护两个表：

```
Database (每个分片一个)
├── main_tables_[16]     ← 主数据表
│   DashTable<NanoObj, NanoObj>
│   key → value
│
└── expire_tables_[16]   ← 过期时间表
    DashTable<NanoObj, int64_t>
    key → expire_at_ms（毫秒级 UNIX 时间戳）
```

**为什么使用独立的过期表？**

```
方案 A: 在值中存储过期时间
  优点: 查找只需一次
  缺点: 所有值都增大 8 字节，即使没有过期时间
        主动扫描需要遍历所有键

方案 B: 独立的过期表（NanoRedis 选择）
  优点: 无过期的键零开销
        主动扫描只遍历有过期时间的键
  缺点: 设置/查询过期需要两次表操作
```

### 4.3 惰性过期

每次读取键时，先检查是否过期：

```cpp
void Database::PruneExpiredInDB(size_t db_index, const NanoObj& key, int64_t now_ms) {
    if (!IsExpiredInDB(db_index, key, now_ms)) {
        return;  // 未过期或没有过期时间
    }
    // 从两个表中删除
    tables[db_index]->Erase(key);
    expire_tables[db_index]->Erase(key);
}
```

**调用时机**：

```
GET key
    ├── PruneExpiredInDB(key)  ← 先检查过期
    │   ├── 已过期 → 删除键 → 返回 nil
    │   └── 未过期 → 继续
    └── tables[db]->Find(key)  ← 正常查找

EXISTS key
    ├── PruneExpiredInDB(key)  ← 先检查过期
    └── tables[db]->Find(key)

TTL key
    ├── PruneExpiredInDB(key)  ← 先检查过期
    └── expire_tables[db]->Find(key)
```

### 4.4 主动过期

每个分片运行一个独立的 Fiber，定期扫描并清理过期键：

```
Active Expire Fiber（每个 vCPU 一个）:

while (running) {
    photon::thread_usleep(100ms);  // 每 100ms 执行一次
    │
    ▼
    ActiveExpireCycle(max_keys_per_db=32):
    │
    ├── for each db in [0, 15]:
    │   │
    │   ├── 遍历 expire_table（最多 32 个键）
    │   │   │
    │   │   ├── 已过期? → 加入删除列表
    │   │   └── 未过期? → 跳过
    │   │
    │   └── 批量删除过期键
    │       tables[db]->Erase(key)
    │       expire_tables[db]->Erase(key)
    │
    └── 返回删除的键数量
}
```

**为什么用两阶段（先收集后删除）？**

在遍历 `expire_table` 的过程中不能直接删除元素（会导致迭代器失效）。所以先收集过期键，再批量删除。

### 4.5 EXPIRE / TTL 命令

**EXPIRE key seconds**：

```
EXPIRE mykey 60
    │
    ├── 计算过期时间戳
    │   expire_at_ms = CurrentTimeMs() + 60 * 1000
    │
    ├── 检查键是否存在
    │   tables[db]->Find("mykey")
    │   ├── 不存在 → 返回 :0
    │   └── 存在 → 继续
    │
    ├── 在 expire_table 中设置/更新
    │   expire_tables[db]->Insert("mykey", expire_at_ms)
    │   （如果已存在则更新）
    │
    └── 返回 :1
```

**TTL key**：

```
TTL mykey
    │
    ├── PruneExpiredInDB("mykey")  ← 先惰性检查
    │
    ├── 查找键
    │   tables[db]->Find("mykey")
    │   ├── 不存在 → 返回 :-2（键不存在）
    │   └── 存在 → 继续
    │
    ├── 查找过期时间
    │   expire_tables[db]->Find("mykey")
    │   ├── 不存在 → 返回 :-1（无过期时间）
    │   └── 存在 → expire_at_ms
    │
    └── 返回 remaining = (expire_at_ms - now_ms) / 1000
```

**PERSIST key**：

```
PERSIST mykey
    │
    ├── 从 expire_table 中删除过期时间
    │   expire_tables[db]->Erase("mykey")
    │   ├── 成功 → 返回 :1（已移除过期时间）
    │   └── 不存在 → 返回 :0
    │
    └── 键的值不受影响
```

### 4.6 SET 的 EX/PX 选项

`SET` 命令可以在设置值的同时设置过期时间：

```
SET key value EX 60       ← 60 秒后过期
SET key value PX 60000    ← 60000 毫秒后过期

实现:
    ├── 设置值: tables[db]->Insert(key, value)
    │
    └── 设置过期:
        if (has_ex) expire_at = now_ms + ex * 1000
        if (has_px) expire_at = now_ms + px
        expire_tables[db]->Insert(key, expire_at)
```

### 4.7 时间处理

```cpp
int64_t CurrentTimeMs() {
    auto now = std::chrono::steady_clock::now();
    return std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()
    ).count();
}
```

**为什么用 `steady_clock` 而不是 `system_clock`？**

- `system_clock` 可能被 NTP 调整（时间跳变），导致过期判断异常
- `steady_clock` 单调递增，不受系统时间调整影响

**溢出保护**：

```cpp
// 如果 now_ms + ttl_ms 溢出，设置为最大值
if (ttl_ms > INT64_MAX - now_ms) {
    expire_at_ms = INT64_MAX;  // 实际上永不过期
} else {
    expire_at_ms = now_ms + ttl_ms;
}
```

## 5. DEL 命令的多键处理

`DEL key1 key2 key3` 涉及多个键，可能分布在不同分片：

```
DEL key1 key2 key3
    │
    ├── 按分片分组
    │   key1 → shard 0
    │   key2 → shard 2
    │   key3 → shard 0
    │
    │   shard 0: [key1, key3]
    │   shard 2: [key2]
    │
    ├── 并行发送到各分片
    │   Await(shard 0, delete [key1, key3])  → 删除 2 个
    │   Await(shard 2, delete [key2])        → 删除 1 个
    │
    ├── 聚合结果
    │   total_deleted = 2 + 1 = 3
    │
    └── 返回 :3
```

## 6. SELECT 命令与多数据库

Redis 支持 16 个逻辑数据库（编号 0-15）：

```
SELECT 2
    │
    ├── 验证参数: 0 ≤ db_index ≤ 15
    │
    ├── 更新 Connection 的 db_index
    │   connection->db_index = 2
    │   （注意：是连接级别的状态，不是全局的）
    │
    └── 后续命令使用 tables[2] 和 expire_tables[2]
```

每个连接可以独立选择数据库，互不影响。

## 7. 命令处理的完整调用链

```
TCP recv()
    │
    ▼
RESPParser::ParseCommand()
    │  args = ["SET", "mykey", "myvalue", "EX", "60"]
    ▼
ProactorPool::HandleConnection()
    │
    ├── CommandRegistry::FindMeta("SET")
    │   → meta = {arity:-3, first_key:1, flags:write}
    │
    ├── 参数校验: args.size() >= |arity|
    │
    ├── 提取键: key = args[meta.first_key]
    │
    ├── 计算分片: shard = Hash(key) % num_shards
    │
    ├── 路由:
    │   ├── 本地: handler(args, context)
    │   └── 远程: Await(shard, handler)
    │
    │   handler = StringFamily::Set
    │       ├── 解析 EX 60 → ttl_ms = 60000
    │       ├── db.Set(key, value)
    │       ├── db.Expire(key, ttl_ms)
    │       └── conn.AppendResponse("+OK\r\n")
    │
    ├── TryParseCommandNoRead() → Pipeline 继续
    │
    └── Flush() → TCP send()
```

---

上一篇：[RESP 协议解析与 Pipeline 批处理](4.resp_and_pipeline.md)
下一篇：[性能分析与调试工具](6.performance_and_debug.md)
