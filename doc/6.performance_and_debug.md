# 性能分析与调试工具

> 构建高性能服务器不仅需要好的架构设计，还需要能够发现和定位性能瓶颈。本文介绍 NanoRedis 中的性能设计决策，以及如何使用 Linux 性能工具和 Valgrind 来分析和调试服务器。

## 1. NanoRedis 的性能设计

### 1.1 性能关键路径

一个 GET 请求的延迟分解：

```
GET mykey 的延迟组成:

  网络接收 (recv)       ~1.0 μs   ← io_uring 或 epoll
  RESP 解析             ~0.1 μs   ← 固定缓冲区，零拷贝
  命令查找              ~0.05 μs  ← 哈希表 O(1)
  分片路由              ~0.02 μs  ← hash % N
  DashTable 查找        ~0.05 μs  ← 两级索引
  响应构造              ~0.05 μs  ← 预定义常量
  网络发送 (send)       ~1.0 μs   ← 缓冲批量发送
  ──────────────────────────────
  总计                  ~2.3 μs

  跨分片额外开销        ~1-2 μs   ← TaskQueue + Fiber 切换
```

### 1.2 各层优化策略

```
┌──────────────────────────────────────────────────────┐
│ 层次            │ 优化策略          │ 效果           │
├──────────────────────────────────────────────────────┤
│ 网络 I/O       │ SO_REUSEPORT      │ 消除 accept 瓶颈│
│                │ io_uring          │ 减少系统调用    │
│                │ Pipeline 批处理    │ 合并 send/recv │
├──────────────────────────────────────────────────────┤
│ 并发模型       │ Fiber             │ 万级连接无开销  │
│                │ Thread-per-Core   │ 无上下文切换    │
├──────────────────────────────────────────────────────┤
│ 数据结构       │ NanoObj (16B)     │ 缓存友好       │
│                │ DashTable         │ 增量扩容       │
│                │ ankerl::dense     │ 连续内存       │
├──────────────────────────────────────────────────────┤
│ 内存           │ 内联字符串        │ 减少堆分配     │
│                │ 整数键优化        │ 减少内存占用   │
│                │ mimalloc          │ 多线程分配性能 │
├──────────────────────────────────────────────────────┤
│ 架构           │ Shared-Nothing    │ 无锁数据路径   │
│                │ 无锁 TaskQueue    │ 避免锁竞争     │
└──────────────────────────────────────────────────────┘
```

## 2. 基准测试

### 2.1 使用 redis-benchmark

```bash
# 基本 SET/GET 性能
redis-benchmark -p 9527 -t set,get -n 100000

# Pipeline 模式（每批 16 个命令）
redis-benchmark -p 9527 -t set,get -n 100000 -P 16

# 多客户端
redis-benchmark -p 9527 -t set,get -n 100000 -c 50

# 指定数据大小
redis-benchmark -p 9527 -t set -n 100000 -d 256
```

### 2.2 关键性能指标

```
指标              目标值                 说明
──────────────    ──────────────         ──────────
吞吐量            >10 万 ops/s/核        每核每秒操作数
P50 延迟          <1 ms                  50% 请求延迟
P99 延迟          <5 ms                  99% 请求延迟
Pipeline 吞吐     >50 万 ops/s/核        Pipeline=16 时
内存效率          <100 字节/键            包含所有元数据开销
```

### 2.3 Pipeline 的效果验证

```bash
# 无 Pipeline
redis-benchmark -p 9527 -t set -n 100000 -P 1
# 预期: ~10 万 ops/s

# Pipeline = 16
redis-benchmark -p 9527 -t set -n 100000 -P 16
# 预期: ~50 万 ops/s（5x 提升）

# Pipeline = 64
redis-benchmark -p 9527 -t set -n 100000 -P 64
# 预期: ~100 万 ops/s（10x 提升）
```

Pipeline 的提升来自减少系统调用和网络往返。

## 3. ON-CPU 分析：找到 CPU 热点

### 3.1 什么是 ON-CPU 分析？

ON-CPU 分析回答的问题是：**CPU 把时间花在了哪些函数上？**

```
ON-CPU 分析适用于:
  ✓ CPU 使用率高
  ✓ 想知道哪个函数最耗 CPU
  ✓ 优化计算密集型代码

不适用于:
  ✗ CPU 使用率低但延迟高（可能是 I/O 等待）
  ✗ 间歇性卡顿（可能是 OFF-CPU 问题）
```

### 3.2 使用 BPF 工具

```bash
# 采集 ON-CPU 火焰图数据
# -p: 目标进程 PID
# -f: 输出折叠格式（可直接转火焰图）
# 99: 采样频率（每秒 99 次）
sudo profile-bpfcc -p <pid> -f 99 > oncpu.txt

# 持续采集 30 秒
sudo profile-bpfcc -p <pid> -f 99 -d 30 > oncpu.txt
```

### 3.3 使用 perf

```bash
# 采集性能数据
sudo perf record -p <pid> -g -- sleep 30

# 查看报告
sudo perf report

# 生成火焰图数据
sudo perf script > perf.out
```

### 3.4 阅读火焰图

```
火焰图自底向上阅读:

  宽度 = 时间占比（越宽越耗 CPU）
  高度 = 调用栈深度

  示例:
  ┌─────────────────────────────────────────────┐
  │              DashTable::Find                 │  ← 热点函数
  ├─────────────────────┬───────────────────────┤
  │  StringFamily::Get  │ HashFamily::HGet      │
  ├─────────────────────┴───────────────────────┤
  │        ProactorPool::HandleConnection        │
  ├─────────────────────────────────────────────┤
  │              VcpuMain                        │
  └─────────────────────────────────────────────┘

  如果 DashTable::Find 占比过大 → 优化哈希表查找
  如果 RESPParser 占比过大 → 优化协议解析
```

## 4. OFF-CPU 分析：找到等待原因

### 4.1 什么是 OFF-CPU 分析？

OFF-CPU 分析回答的问题是：**线程在等待什么？等了多久？**

```
OFF-CPU 分析适用于:
  ✓ CPU 使用率不高但响应慢
  ✓ 线程频繁阻塞（I/O、锁、sleep）
  ✓ Fiber 调度问题

典型发现:
  - 某个 recv() 阻塞了 50ms → 客户端发送慢
  - TaskQueue 等待 → 跨分片请求排队
  - Fiber sleep → 主动过期周期
```

### 4.2 使用 BPF 工具

```bash
# 采集 OFF-CPU 数据
# 输出格式: 调用栈 + 阻塞时间（微秒）
sudo offcputime-bpfcc -p <pid> > offcpu.txt

# 限制采集时间
sudo offcputime-bpfcc -p <pid> -d 30 > offcpu.txt

# 只看阻塞超过 1ms 的
sudo offcputime-bpfcc -p <pid> --min-block-time 1000 > offcpu.txt
```

### 4.3 分析 OFF-CPU 结果

```
常见的 OFF-CPU 模式:

① I/O 等待
   epoll_wait / io_uring_enter
   → 正常：没有请求时等待
   → 异常：有请求但在等待 → 检查网络

② Fiber 调度
   photon::thread_yield / photon::thread_usleep
   → 正常：Fiber 主动让出
   → 异常：频繁切换 → 可能 Fiber 过多

③ 跨分片等待
   semaphore::wait → TaskQueue::Await
   → 正常：跨分片请求
   → 异常：等待时间过长 → 目标分片繁忙

④ 主动过期
   thread_usleep(100ms) → ActiveExpireCycle
   → 正常：定时唤醒
```

## 5. Valgrind：内存问题排查

### 5.1 常见内存问题

```
问题                      表现                     严重性
──────────────────       ──────────────────        ────
使用未初始化变量           随机行为、偶发崩溃         中
读取已释放内存             崩溃、数据损坏             高
写入已释放内存             崩溃、数据损坏             高
缓冲区溢出                崩溃、安全漏洞             高
内存泄漏（可达）           内存持续增长               低
内存泄漏（不可达）         内存持续增长               中
```

### 5.2 基本使用

```bash
# 安装
sudo apt-get install valgrind

# 内存检测（运行单元测试）
valgrind --tool=memcheck --leak-check=full ./build/unit_tests

# 针对特定测试
valgrind --tool=memcheck --leak-check=full \
    ./build/unit_tests --gtest_filter=StringFamilyTest.IncrNewKey

# 追踪未初始化值的来源
valgrind --tool=memcheck --track-origins=yes ./build/unit_tests
```

### 5.3 实战案例：NanoObj 未初始化 Bug

**问题描述**：`INCR` 命令偶发 coredump。

**第一步：尝试复现**

```bash
for i in {1..10}; do
    echo "Run $i:"
    ./build/unit_tests --gtest_filter=StringFamilyTest.IncrNewKey 2>&1 | tail -3
done
# 结果: 10 次全部通过 → 非确定性问题
```

**第二步：使用 Valgrind**

```bash
valgrind --tool=memcheck --leak-check=full \
    ./build/unit_tests --gtest_filter=StringFamilyTest.IncrNewKey
```

**关键错误信息**：

```
Conditional jump or move depends on uninitialised value(s)
   at NanoObj::clear()
   by NanoObj::setInt(long)
   by NanoObj::NanoObj(long)
   by NanoObj::fromInt(long)
   by StringFamily::Incr(...)
```

**第三步：分析调用链**

```
NanoObj::NanoObj(int64_t val)     构造函数
  └─► NanoObj::setInt(val)       设置整数值
        └─► NanoObj::clear()     释放旧资源
              └─► getTag()       读取 taglen_ ← 问题点！
```

**根因**：构造函数直接调用 `setInt()`，而 `setInt()` 调用 `clear()` 释放旧资源。`clear()` 读取 `taglen_` 判断需要释放什么类型的资源——但此时 `taglen_` 尚未初始化，包含垃圾值。如果垃圾值恰好等于 `SMALL_STR_TAG`，就会尝试释放一个无效指针，导致崩溃。

**修复**：在 `setInt()` 之前先初始化 `taglen_`：

```cpp
NanoObj::NanoObj(int64_t val) : taglen_(NULL_TAG), flag_(0) {
    setInt(val);  // 现在 clear() 看到 NULL_TAG，不会释放任何东西
}
```

### 5.4 Valgrind 错误类型速查

| 错误类型 | 含义 | 严重性 | 典型原因 |
|---------|------|-------|---------|
| `Invalid read of size N` | 读取无效内存 | 高 | 使用已释放的指针、数组越界 |
| `Invalid write of size N` | 写入无效内存 | 高 | 缓冲区溢出、写入已释放内存 |
| `Conditional jump depends on uninitialised value` | 条件判断用了未初始化变量 | 中 | 忘记初始化成员变量 |
| `Use of uninitialised value` | 使用了未初始化值 | 中 | 变量未初始化就使用 |
| `definitely lost` | 内存泄漏（指针丢失） | 中 | 忘记 delete/free |
| `still reachable` | 内存未释放但指针仍在 | 低 | 全局对象未清理（通常无害） |
| `Mismatched free()` | 释放方式不匹配 | 中 | new[] 配 delete（应该用 delete[]）|

### 5.5 Valgrind 常用选项

```bash
# 只显示错误（不显示正常输出）
valgrind --tool=memcheck -q ./build/unit_tests

# 输出到文件
valgrind --tool=memcheck --log-file=valgrind.log ./build/unit_tests

# 显示所有泄漏类型
valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./build/unit_tests

# 生成抑制文件（过滤已知问题）
valgrind --tool=memcheck --gen-suppressions=all ./build/unit_tests > suppressions.supp

# 使用抑制文件
valgrind --tool=memcheck --suppressions=suppressions.supp ./build/unit_tests
```

### 5.6 竞态条件检测

虽然 NanoRedis 使用 Shared-Nothing 架构避免了大部分竞态，但 TaskQueue 等跨线程组件仍需验证：

```bash
# Helgrind 检测线程竞态
valgrind --tool=helgrind ./build/unit_tests

# 常见误报: PhotonLibOS 内部的同步机制
# 可以使用 suppressions 过滤
```

## 6. 调试技巧

### 6.1 GDB 调试 Fiber 程序

```bash
# 启动调试
gdb ./build/nano_redis_server

# 设置断点
(gdb) break StringFamily::Set
(gdb) break DashTable::Insert

# 运行
(gdb) run --num_shards=1 --port=9527

# 在另一个终端发送命令
# redis-cli -p 9527 SET hello world

# Fiber 的调用栈可能比较深，使用 bt 查看
(gdb) bt
```

### 6.2 日志调试

```bash
# 调试模式编译（保留符号信息）
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build -j

# 使用单分片运行（简化调试）
./build/nano_redis_server --num_shards=1 --port=9527
```

### 6.3 单元测试调试

```bash
# 运行特定测试并查看输出
./build/unit_tests --gtest_filter=DashTableTest.* -v

# 使用 gdb 调试特定测试
gdb --args ./build/unit_tests --gtest_filter=StringFamilyTest.SetAndGet

# 使用 Valgrind 检查特定测试
valgrind --tool=memcheck ./build/unit_tests --gtest_filter=StringFamilyTest.SetAndGet
```

## 7. 性能调优清单

当需要优化 NanoRedis 性能时，按以下顺序排查：

```
① 系统层面
   ├── CPU 是否达到瓶颈？ → top / htop
   ├── 内存是否充足？ → free -h
   ├── 网络是否饱和？ → iftop
   └── 磁盘 I/O？ → 纯内存服务器通常不涉及

② 架构层面
   ├── 分片数是否合理？ → 应等于 CPU 核心数
   ├── 是否有热点分片？ → 观察各分片负载
   └── 跨分片请求比例？ → 理想情况 1/N

③ 应用层面
   ├── Pipeline 是否启用？ → redis-benchmark -P 16
   ├── 是否有大键？ → 大键会阻塞单个分片
   └── 过期键比例？ → 过多过期键增加扫描开销

④ 代码层面
   ├── ON-CPU 热点？ → profile-bpfcc / perf
   ├── OFF-CPU 等待？ → offcputime-bpfcc
   ├── 内存问题？ → valgrind
   └── 缓存命中率？ → perf stat -e cache-misses
```

---

上一篇：[命令处理与 TTL 过期机制](5.command_and_ttl.md)

---

## 附录：工具安装

```bash
# BPF 工具
sudo apt-get install bpfcc-tools linux-headers-$(uname -r)

# Valgrind
sudo apt-get install valgrind

# perf
sudo apt-get install linux-tools-common linux-tools-$(uname -r)

# 火焰图工具
git clone https://github.com/brendangregg/FlameGraph.git

# 生成火焰图
cat oncpu.txt | FlameGraph/flamegraph.pl > oncpu.svg
```
